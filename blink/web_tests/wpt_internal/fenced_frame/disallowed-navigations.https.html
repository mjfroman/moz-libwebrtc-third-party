<!DOCTYPE html>
<title>Fenced frame disallowed navigations</title>
<meta name="timeout" content="long">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/common/dispatcher/dispatcher.js"></script>
<script src="/common/get-host-info.sub.js"></script>
<script src="/common/utils.js"></script>
<script src="resources/utils.js"></script>
<script src="/fetch/private-network-access/resources/support.sub.js"></script>

<body>

<script>
// Baseline tests:
//   - Embedder can navigate iframe to blob: URL
//   - Embedder can navigate iframe to data: URL
//   - Same-origin embedder can navigate iframe to javascript: URL
//   - Embedder can navigate iframe to http: URL
// Fenced frame tests:
//   - Embedder cannot navigate fenced frame (mode=default) to blob: URL
//   - Embedder cannot navigate fenced frame (mode=default) to data: URL
//   - Same-origin embedder cannot navigate fenced frame (mode=default) to
//     javascript: URL
//   - Embedder cannot navigate fenced frame (mode=default) to http: URL

// Fenced frames are always put in the public IP address space which is the
// least privileged. In case a navigation to a local data: URL or blob: URL
// resource is allowed, they would only be able to fetch things that are *also*
// in the public IP address space. So for the document described by these local
// URLs, we'll set them up to only communicate back to the outer page via
// resources obtained in the public address space.
const kPublicUtils = resolveUrl("resources/utils.js", Server.HTTPS_PUBLIC);
const kPublicOrigin = kPublicUtils.origin;
function createLocalSource(key) {
  return `
    <head>
      <script src="${kPublicUtils}"><\/script>
    </head>
    <body>
      <script>
        writeValueToServer("${key}", "LOADED", /*origin=*/"${kPublicOrigin}");
      <\/script>
    </body>
  `;
}

// These are used in tests that rely on URLs containing dangling markup. See
// https://github.com/whatwg/fetch/pull/519.
const kDanglingMarkupSubstrings = [
  "blo\nck<ed",
  "blo\rck<ed",
  "blo\tck<ed",
  "blo<ck\ned",
  "blo<ck\red",
  "blo<ck\ted",
];

// These are just baseline tests asserting that this test's machinery to load
// blob:, data:, and javascript: URLs work properly in contexts where they are
// expected to.
promise_test(async () => {
  const key = token();
  attachIFrame(`data:text/html,${createLocalSource(key)}`);
  const result = await nextValueFromServer(key);
  assert_equals(result, "LOADED");
}, "iframe data: URL");

promise_test(async () => {
  const key = token();
  const blobURL = URL.createObjectURL(
      new Blob([`${createLocalSource(key)}`], {type: 'text/html'}));
  attachIFrame(blobURL);
  const result = await nextValueFromServer(key);
  assert_equals(result, "LOADED");
}, "iframe blob: URL");

promise_test(async () => {
  const iframe = attachIFrameContext();
  iframe.src = "javascript:window.jsURLExecuted = true;"
  await iframe.execute(async () => {
    assert_equals(window.jsURLExecuted, true);
  });
}, "iframe javascript: URL");

function getTimeoutPromise(t) {
  return new Promise(resolve =>
      t.step_timeout(() => resolve("NOT LOADED"), 2000));
}

// The following tests ensure that an embedder cannot navigate a fenced frame
// (with different modes) to:
//   - data: URLs
//   - blob: URLs
//   - javascript: URLs
//   - http: URLs
//   - https: URLs with dangling markup
for (const mode of ['opaque-ads', 'default']) {

  promise_test(async t => {
    const key = token();
    attachFencedFrame(`data:text/html,${createLocalSource(key)}`, /*mode=*/mode);
    const loaded_promise = nextValueFromServer(key);
    const result = await Promise.any([loaded_promise, getTimeoutPromise(t)]);
    assert_equals(result, "NOT LOADED");
  }, `fenced frame mode=${mode} data: URL`);

  promise_test(async t => {
    const key = token();
    const blobURL = URL.createObjectURL(
        new Blob([`${createLocalSource(key)}`], {type: 'text/html'}));
    attachFencedFrame(blobURL, /*mode=*/mode);
    const loaded_promise = nextValueFromServer(key);
    const result = await Promise.any([loaded_promise, getTimeoutPromise(t)]);
    assert_equals(result, "NOT LOADED");
  }, `fenced frame mode=${mode} blob: URL`);

  promise_test(async t => {
    const fencedframe = attachFencedFrameContext({mode: ['mode', mode]});
    fencedframe.src = "javascript:window.jsURLExecuted = true;"
    // Just in case the javascript URL executes asynchronously, let's wait for
    // it.
    await getTimeoutPromise(t);
    await fencedframe.execute(async () => {
      assert_equals(window.jsURLExecuted, undefined);
    });
  }, `fenced frame mode=${mode} javascript: URL`);

  promise_test(async t => {
    const key = token();
    let http_url = new URL("resources/embeddee.html",
        get_host_info().HTTP_ORIGIN + location.pathname);
    http_url = generateURL(http_url, [key]);
    assert_equals(http_url.protocol, "http:");
    const fencedframe = attachFencedFrame(http_url, /*mode=*/mode);
    const loaded_promise = nextValueFromServer(key);
    const result = await Promise.any([loaded_promise, getTimeoutPromise(t)]);
    assert_equals(result, "NOT LOADED");
  }, `fenced frame mode=${mode} http: URL`);

  // These tests assert that fenced frames cannot be navigated to HTTPs URLs
  // with dangling markup.
  for (substring of kDanglingMarkupSubstrings) {
    promise_test(async t => {
      const key = token();
      let url_string = generateURL("resources/embeddee.html?blocked", [key]).toString();
      url_string = url_string.replace("blocked", substring);
      const fencedframe = attachFencedFrame(url_string, /*mode=*/mode);
      const loaded_promise = nextValueFromServer(key);
      const result = await Promise.any([loaded_promise, getTimeoutPromise(t)]);
      assert_equals(result, "NOT LOADED");
    }, `fenced frame mode=${mode} dangling-markup URL with '${substring}'`);
  }
} // end for.

// The following tests ensure that an embedder cannot navigate a
// `mode=opaque-ads` fenced frame to an opaque URN that represents a:
//   - data: URL
//   - blob: URL
//   - javascript: URL
//   - http: URL
//   - https: URL with dangling markup
promise_test(async t => {
  const key = token();
  const urn = await generateURN(`data:text/html,${createLocalSource(key)}`);
  attachFencedFrame(urn, /*mode=*/'opaque-ads');
  const loaded_promise = nextValueFromServer(key);
  const result = await Promise.any([loaded_promise, getTimeoutPromise(t)]);
  assert_equals(result, "NOT LOADED");
}, "fenced frame opaque URN => data: URL");

promise_test(async t => {
  const key = token();
  const blobURL = URL.createObjectURL(
      new Blob([`${createLocalSource(key)}`], {type: 'text/html'}));
  const urn = await generateURN(blobURL);
  attachFencedFrame(urn, /*mode=*/'opaque-ads');
  const loaded_promise = nextValueFromServer(key);
  const result = await Promise.any([loaded_promise, getTimeoutPromise(t)]);
  assert_equals(result, "NOT LOADED");
}, "fenced frame opaque URN => blob: URL");

promise_test(async () => {
  const fencedframe = attachFencedFrameContext(
      {attributes: ['mode', 'opaque-ads']});
  const urn = await generateURN("javascript:window.jsURLExecuted = true;");
  fencedframe.src = urn;
  // Just in case the javascript URL executes asynchronously, let's wait for it.
  await fencedframe.execute(async () => {
    assert_equals(window.jsURLExecuted, undefined);
  });
}, "fenced frame opaque URN => javascript: URL");

promise_test(async t => {
  const key = token();
  const http_url = new URL("resources/embeddee.html",
      get_host_info().HTTP_ORIGIN + location.pathname);
  const urn = await generateURN(http_url, [key]);
  const fencedframe = attachFencedFrame(urn, /*mode=*/'opaque-ads');
  const loaded_promise = nextValueFromServer(key);
  const result = await Promise.any([loaded_promise, getTimeoutPromise(t)]);
  assert_equals(result, "NOT LOADED");
}, "fenced frame opaque URN => http: URL");

// These tests assert that fenced frames cannot be navigated to a urn:uuid URL
// that represents an HTTPS URLs with dangling markup.
for (substring of kDanglingMarkupSubstrings) {
  promise_test(async t => {
    const key = token();

    // Copied from from `generateURN()`, since we have to modify the final URL
    // that goes into `selectURL`.
    try {
      await sharedStorage.worklet.addModule(
        "/wpt_internal/shared_storage/resources/simple-module.js");
    } catch (e) {
      // See documentation in `generateURN()`.
    }

    let url_string = generateURL("resources/report-url.html?blocked", [key]).toString();
    url_string = url_string.replace("blocked", substring);

    const urn = await sharedStorage.selectURL(
      "test-url-selection-operation", [{url: url_string}], {data: {'mockResult': 0}}
    );

    const fencedframe = attachFencedFrame(urn, /*mode=*/'opaque-ads');
    const loaded_promise = nextValueFromServer(key);
    const result = await Promise.any([loaded_promise, getTimeoutPromise(t)]);
    assert_equals(result, "NOT LOADED");
  }, `fenced frame opaque URN => https: URL with dangling markup '${substring}'`);
}

</script>

</body>
