<!doctype html>
<meta charset="utf-8">
<title>WebSQL: printf() does not OOM with large strings</title>
<script src="../../resources/testharness.js"></script>
<script src="../../resources/testharnessreport.js"></script>
<script>
'use strict';

async_test(testCase => {
  const database = openDatabase(
      'PrintfTest', '1.0', 'Database for printf() test',
      1024 * 1024);
  assert_not_equals(database, null, 'openDatabase should not fail');

  database.transaction(testCase.step_func(transaction => {
    transaction.executeSql(
        'DROP TABLE IF EXISTS main;', [], () => {},
        testCase.unreached_func('DROP TABLE should not fail'));
    transaction.executeSql(
        'CREATE TABLE main(id INTEGER PRIMARY KEY);', [], () => {},
        testCase.unreached_func('CREATE TABLE should not fail'));
    transaction.executeSql(
        'INSERT INTO main VALUES(1);', [], () => {},
        testCase.unreached_func('INSERT should not fail'));

    // When SQLITE_PRINTF_PRECISION_LIMIT is not overridden, the printf()
    // statement below produces a string that takes up slightly less than 1GiB
    // of RAM.
    //
    // SQLite's printf buffer is limited by SQLITE_PRINTF_PRECISION_LIMIT
    // and SQLITE_LIMIT_LENGTH [1]. The latter defaults to
    // SQLITE_MAX_LENGTH [2], and Chrome does not override this default via
    // sqlite3_limit() [3]. Chrome uses SQLite's default SQLITE_MAX_LENGTH,
    // which is 1,000,000,000.
    //
    // The statement uses the %X (hexadecimal) specifier instead of the more
    // familiar %d (decimal) in order to reduce the CPU time taken by a failing
    // test. More specifically, in case SQLite ends up doing division for each
    // output character (1 billion times, if SQLITE_PRINTF_PRECISION_LIMIT isn't
    // set), the savings of bit-shifting (used by hexadecimal) over full
    // division (required by decimal) can add up.
    //
    // [1] https://sqlite.org/compile.html#printf_precision_limit and
    // [2] https://sqlite.org/limits.html#max_length.
    // [3] https://sqlite.org/c3ref/c_limit_attached.html#sqlitelimitlength
    const kPrintf1GB = "printf('%1000000000X', id)";

    // Chrome renderers are currently limited to using 4GiB of RAM.
    // of these strings OOM the renderer. 5 printf() statements will produce
    // strings whose combined lengths exceeds 4GiB of RAM.
    //
    // If this test completes, it means it hasn't OOMed, and
    // SQLITE_PRINTF_PRECISION_LIMIT is set to less than 1,000,000,000.
    transaction.executeSql(
        `SELECT ${kPrintf1GB}, ${kPrintf1GB}, ${kPrintf1GB}, ${kPrintf1GB}, ` +
            `${kPrintf1GB} FROM main;`,
        [], testCase.step_func_done(() => {}),
        testCase.unreached_func('printf() should not fail'));
  }));
}, `printf() should not fail or crash with %1000000000X`);
</script>
